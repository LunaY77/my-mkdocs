---
title: Spring 事务
authors: [cangjingyue]
tags: 
    - spring
    - java
categories:
  - java
---

# Spring 事务

## 事务ACID

* **原子性**： **一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成**，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
* **一致性**： 在事务开始之前和事务结束以后，数据库的**完整性**没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
* **隔离性**： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括**读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。**
* **持久性**： 事务处理结束后，对数据的修改就是**永久**的，即便系统故障也不会丢失。

## 事务隔离级别


### **1. 读未提交**

- **ISOLATION_READ_UNCOMMITTED（读未提交）**：其他事务会读取当前事务尚未更改的提交（相当于读取的是这个事务暂时缓存的内容，并不是数据库中的内容）

首先是**读未提交**级别，此级别属于最低级别，相当于各个事务共享一个缓存区域，任何事务的操作都在这里进行。那么它会导致以下问题：

![Pasted image 20240820004523](https://cangjingyue.oss-cn-hangzhou.aliyuncs.com/2024/12/28/pasted-image-20240820004523.png)


也就是说，事务A最后得到的实际上是一个毫无意义的数据（事务B已经回滚了）我们称此数据为 ***"脏数据"*** ，这种现象称为**脏读**

---

### **2. 读已提交**

- **ISOLATION_READ_COMMITTED（读已提交）**：其他事务会读取当前事务已经提交的数据（也就是直接读取数据库中已经发生更改的内容）

我们接着来看`读已提交`级别，事务只能读取其他事务已经提交的内容，相当于直接从数据中读取数据，这样就可以避免**脏读**问题了，但是它还是存在以下问题：

![Pasted image 20240820004721](https://cangjingyue.oss-cn-hangzhou.aliyuncs.com/2024/12/28/pasted-image-20240820004721.png)


这正是我们前面例子中提到的问题，虽然它避免了脏读问题，但是如果事件B修改并提交了数据，那么实际上事务A之前读取到的数据依然不是最新的数据，直接导致两次读取的数据**不一致**，这种现象称为**虚读**也可以称为**不可重复读**


---

### **3. 可重复读**

- **ISOLATION_REPEATABLE_READ（可重复读）**：其他事务会读取当前事务已经提交的数据并且其他事务执行过程中不允许再进行数据修改（注意这里仅仅是不允许修改数据）

因此，下一个隔离级别**可重复读**就能够解决这样的问题（MySQL的默认隔离级别），它规定在其他事务执行时，不允许修改数据，这样，就可以有效地避免不可重复读的问题，但是这样就一定安全了吗？这里仅仅是**禁止了事务执行过程中的UPDATE操作，但是它并没有禁止INSERT这类操作**，因此，如果事务A执行过程中事务B插入了新的数据，那么A这时是毫不知情的，比如：

![Pasted image 20240820004951](https://cangjingyue.oss-cn-hangzhou.aliyuncs.com/2024/12/28/pasted-image-20240820004951.png)


两个人**同时**报名一个活动，两个报名的事务**同时**在进行，但是他们一开始读取到的人数都是**5**，而这时，它们都会认为报名成功后人数应该变成**6**，而正常情况下应该是**7**，因此这个时候就发生了数据的**幻读**现象。

---

### **4. 串行化**

要解决上述种种问题，只能使用最后一种隔离级别**串行化**来实现了，**每个事务不能同时进行**，直接避免所有并发问题，简单粗暴，但是效率爆减，并不推荐。



---

### **5. 小结**

最后总结三种情况：

- **脏读**：读取到了被回滚的数据，它毫无意义。
- **虚读（不可重复读）**：由于其他事务更新数据，两次读取的数据不一致。
- **幻读**：由于其他事务执行插入删除操作，而又无法感知到表中记录条数发生变化，当下次再读取时会莫名其妙多出或缺失数据，就像产生幻觉一样。

*（对于虚读和幻读的区分：虚读是某个数据前后读取不一致，幻读是整个表的记录数量前后读取不一致)*

最后这张图，请务必记在你的脑海，记在你的心中：


<img src="https://cangjingyue.oss-cn-hangzhou.aliyuncs.com/2024/12/28/17353763265466.jpg" style="height:200px; display: block; margin: auto;">



## 事务的传播行为

### 概述

当一个 `service` 中调用了另一个 `service` 的方法，此时 `bservice` 的事务传播到了 `aservice` 中，这样就产生了事务的传播：

```java
@Service
public class AService {

    @Autowired
    private BService bService;
    
    public void order() {
        xxx();
        bService().yyy();
        zzz();
    }
}    
```

因为两个 `service` 都存在事务，那么生成的sql语句可能如下：

```sql
BEGIN;
    update xxx;
    --- 事务分界线 ---
        begin;
            update yyy;
        commit;
    ----------------
    update zzz;
commit;    
```

显然，这里的事务逻辑存在问题，当第二个 `begin` 执行完毕后，会隐式地将第一个事务提交，从而导致 `AService` 的部分事务提交。
所以当 `B事务` 传播到 `A事务` 中时 `B 事务` 需要做一下微调，微调的结果如下述几种情况：


#### **1. 当AService存在事务**

**第一种情况：融入A事务 (即B事务合并入A事务)** 

形成的sql如下：

```sql
BEGIN;
    update xxx;
    --- 事务分界线 ---
        update yyy;
    ----------------
    update zzz;
commit;   
```

<br/> 

**第二种情况：挂起A事务，让B事务独立于A事务运行。**


当两个事务需要**各自独立维护自身事务**，单个事务无法独立完成，B事务启动时可以暂时将A事务挂起，即阻塞A，且不向A发送sql，使得其无法提交，而B开启一个新的事务，B执行完毕后A继续。



<img src="https://cangjingyue.oss-cn-hangzhou.aliyuncs.com/2024/12/28/untitled-diagramdrawio1.png" style="height:400px; display: block; margin: auto;">

---


#### **2. 当AService无事务**

**第一种情况：B事务以事务的方式运行**

```sql
select xxx;
    --- 分界线 ---
    begin;
        update yyy;
    commit;
    -------------
select zzz;    
```

<br/>

**第二种情况：B事务以无事务的方式运行**

```sql
select xxx;
    --- 分界线 ---
    select yyy;
    -------------
select zzz;    
```

----

#### **3. 嵌套事务**

通过设置保存点，将内部的事务转化为 **设置保存点** 和 **回滚至保存点**，实现类似两个事务的操作。

```sql
begin;
    update xxx;
    savepoint a;
        update yyy;
        --- 若报错，回滚至保存点a
    rollback to a;
    --- 后续事务不受影响
    update zzz;
commit;    
```

嵌套过程如下：

1. 内部 `SAVEPOINT a` 后的代码如果报错则直接回滚到保存点
2. 整个事务的提交不收内部 **伪事务** 的影响。


### 传播行为

1. **PROPAGATION_REQUIRED**：表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。REQUIRED 表示需要，即 B事务无论如何都要有事务。
2. **PROPAGATION_SUPPORTS**：表示当前方法不需要事务上下文。但是如果存在当前事务的话，那么该方法会在这个事务中运行
3. **PROPAGATION_MANDATORY**：(强制性的) 表示该方法必须在事务中运行。如果当前事务不存在，则会抛出一个异常。
4. **PROPAGATION_REQUIRES_NEW**：(需要一个新事务) 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。
5. **PROPAGATION_NOT_SUPPORTED**：(不支持事务) 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。
6. **PROPAGATION_NEVER**：(不会运行在有事务的环境) 表示当前方法不应该运行在事务上下文中，如果当前有一个事务正在运行，则会抛出异常
7. **PROPAGATION_NESTED**：(嵌套的) 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行独立地提交或回滚，如果当前事务不存在，那么其行为与 REQUIRED 一样。注意不同数据库对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务。

